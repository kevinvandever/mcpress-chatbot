"""
Conversation Export Service for Story-012
Exports conversations to PDF and Markdown formats
"""

import re
import io
import zipfile
from typing import List, Optional
from datetime import datetime

try:
    from export_models import (
        ExportData, ExportOptions, ExportResult,
        FormattedMessage, CodeBlock, BookReference
    )
    from pdf_generator import PDFGenerator
    from markdown_generator import MarkdownGenerator
except ImportError:
    from backend.export_models import (
        ExportData, ExportOptions, ExportResult,
        FormattedMessage, CodeBlock, BookReference
    )
    from backend.pdf_generator import PDFGenerator
    from backend.markdown_generator import MarkdownGenerator


class ConversationExportService:
    """Export conversations to various formats"""

    def __init__(self, conversation_service, vector_store):
        self.conversations = conversation_service
        self.vector_store = vector_store
        self.pdf = PDFGenerator()
        self.markdown = MarkdownGenerator()

    async def export_conversation(
        self,
        conversation_id: str,
        user_id: str,
        format: str = 'pdf',
        options: Optional[ExportOptions] = None
    ) -> ExportResult:
        """Export conversation to specified format"""

        if options is None:
            options = ExportOptions()

        # Get conversation with messages
        conversation, messages = await self.conversations.get_conversation_with_messages(
            conversation_id, user_id
        )

        # Build export data
        export_data = self._prepare_export_data(
            conversation, messages, options
        )

        # Generate export based on format
        if format == 'pdf':
            file_data = await self.pdf.generate(export_data, options)
            filename = f"{self._sanitize_filename(conversation['title'])}.pdf"
            mime_type = 'application/pdf'

        elif format == 'markdown':
            file_data = await self.markdown.generate(export_data, options)
            filename = f"{self._sanitize_filename(conversation['title'])}.md"
            mime_type = 'text/markdown'

        else:
            raise ValueError(f"Unsupported format: {format}")

        # Save export record
        export_record = await self._save_export_record(
            user_id, conversation_id, format, filename
        )

        return ExportResult(
            id=export_record['id'] if export_record else None,
            filename=filename,
            file_data=file_data,
            mime_type=mime_type,
            size=len(file_data)
        )

    async def bulk_export(
        self,
        conversation_ids: List[str],
        user_id: str,
        format: str = 'pdf',
        options: Optional[ExportOptions] = None
    ) -> ExportResult:
        """Export multiple conversations"""

        # Export each conversation
        exports = []
        for conv_id in conversation_ids:
            try:
                export = await self.export_conversation(
                    conv_id, user_id, format, options
                )
                exports.append(export)
            except Exception as e:
                print(f"⚠️ Failed to export conversation {conv_id}: {e}")
                continue

        # If only one successful export, return it directly
        if len(exports) == 1:
            return exports[0]
        elif len(exports) == 0:
            raise Exception("No conversations were successfully exported")
        else:
            # Create ZIP archive
            zip_data = self._create_zip_archive(exports)
            filename = f"conversations_export_{len(exports)}.zip"

            return ExportResult(
                filename=filename,
                file_data=zip_data,
                mime_type='application/zip',
                size=len(zip_data)
            )

    def _prepare_export_data(
        self,
        conversation: dict,
        messages: List[dict],
        options: ExportOptions
    ) -> ExportData:
        """Prepare conversation data for export"""

        return ExportData(
            title=options.custom_title or conversation.get('title', 'Conversation'),
            subtitle=options.subtitle,
            metadata={
                'created_at': conversation.get('created_at'),
                'updated_at': conversation.get('updated_at'),
                'message_count': len(messages),
                'tags': conversation.get('tags', []),
                'summary': conversation.get('summary')
            },
            messages=[
                self._format_message(msg, options)
                for msg in messages
            ],
            table_of_contents=options.include_toc,
            footer=options.footer or "Generated by MC Press Chatbot"
        )

    def _format_message(
        self,
        message: dict,
        options: ExportOptions
    ) -> FormattedMessage:
        """Format message for export"""

        # Extract code blocks
        code_blocks = self._extract_code_blocks(message.get('content', ''))

        # Extract book references from metadata
        metadata = message.get('metadata', {})
        book_refs_data = metadata.get('book_references', [])

        book_refs = []
        for ref in book_refs_data:
            if isinstance(ref, dict):
                book_refs.append(BookReference(
                    title=ref.get('title', 'Unknown'),
                    author=ref.get('author', 'Unknown')
                ))

        return FormattedMessage(
            role=message.get('role', 'user'),
            content=message.get('content', ''),
            code_blocks=code_blocks,
            book_references=book_refs,
            timestamp=message.get('created_at') if options.include_timestamps else None
        )

    def _extract_code_blocks(self, content: str) -> List[CodeBlock]:
        """Extract code blocks with language tags"""

        pattern = r'```(\w+)?\n(.*?)```'
        matches = re.finditer(pattern, content, re.DOTALL)

        code_blocks = []
        for match in matches:
            language = match.group(1) or 'text'
            code = match.group(2).strip()
            code_blocks.append(CodeBlock(language=language, code=code))

        return code_blocks

    def _sanitize_filename(self, filename: str) -> str:
        """Sanitize filename to be filesystem-safe"""
        # Remove or replace invalid characters
        sanitized = re.sub(r'[<>:"/\\|?*]', '_', filename)
        # Limit length
        if len(sanitized) > 200:
            sanitized = sanitized[:200]
        return sanitized or "export"

    def _create_zip_archive(self, exports: List[ExportResult]) -> bytes:
        """Create ZIP archive from multiple exports"""

        zip_buffer = io.BytesIO()

        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for export in exports:
                zip_file.writestr(export.filename, export.file_data)

        return zip_buffer.getvalue()

    async def _save_export_record(
        self,
        user_id: str,
        conversation_id: str,
        format: str,
        filename: str
    ) -> Optional[dict]:
        """Save export record to database"""

        try:
            if not hasattr(self.vector_store, 'pool') or not self.vector_store.pool:
                print("⚠️ No database connection - skipping export record")
                return None

            async with self.vector_store.pool.acquire() as conn:
                # Generate unique ID
                import uuid
                export_id = str(uuid.uuid4())

                await conn.execute("""
                    INSERT INTO conversation_exports
                    (id, user_id, conversation_id, format, filename, created_at)
                    VALUES ($1, $2, $3, $4, $5, NOW())
                """, export_id, user_id, conversation_id, format, filename)

                return {'id': export_id}

        except Exception as e:
            print(f"⚠️ Failed to save export record: {e}")
            return None

    async def list_exports(self, user_id: str) -> List[dict]:
        """List user's export history"""

        try:
            if not hasattr(self.vector_store, 'pool') or not self.vector_store.pool:
                return []

            async with self.vector_store.pool.acquire() as conn:
                rows = await conn.fetch("""
                    SELECT id, conversation_id, format, filename, created_at
                    FROM conversation_exports
                    WHERE user_id = $1
                    ORDER BY created_at DESC
                    LIMIT 50
                """, user_id)

                return [dict(row) for row in rows]

        except Exception as e:
            print(f"⚠️ Failed to list exports: {e}")
            return []

    async def delete_export_record(self, export_id: str, user_id: str) -> bool:
        """Delete an export record"""

        try:
            if not hasattr(self.vector_store, 'pool') or not self.vector_store.pool:
                return False

            async with self.vector_store.pool.acquire() as conn:
                result = await conn.execute("""
                    DELETE FROM conversation_exports
                    WHERE id = $1 AND user_id = $2
                """, export_id, user_id)

                return 'DELETE' in result

        except Exception as e:
            print(f"⚠️ Failed to delete export record: {e}")
            return False
