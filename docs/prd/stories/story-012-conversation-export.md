# Story: Conversation Export

**Story ID**: STORY-012
**Epic**: EPIC-002 (Core Productivity Suite)
**Type**: New Feature
**Priority**: P1 (High)
**Points**: 3
**Sprint**: 10
**Status**: Ready for Development

## User Story

**As a** user
**I want** to export conversations to PDF and Markdown
**So that** I can share knowledge with my team and create documentation

## Context

Conversation export enables users to transform chat interactions into shareable, professional documentation. This is critical for team knowledge sharing, creating training materials, documenting solutions, and preserving important technical discussions. By supporting multiple formats (PDF, Markdown), we accommodate different use cases from formal reports to developer documentation.

## Current State

### Existing System
- **Conversation History**: STORY-011 provides persistent conversation storage
- **Chat Interface**: Conversations with formatted messages, code blocks
- **Database**: Conversations and messages stored in PostgreSQL
- **Metadata**: Book references, code snippets, topics available

### Gap Analysis
- No export functionality
- Cannot share conversations outside platform
- No way to create documentation from chats
- No formatted output for printing
- Cannot preserve conversations for compliance/auditing

## Acceptance Criteria

### Core Export Features
- [ ] Export single conversation to PDF
- [ ] Export single conversation to Markdown
- [ ] Export multiple conversations (bulk export)
- [ ] Syntax highlighting in exported code blocks
- [ ] Include conversation metadata (title, date, tags)
- [ ] Custom title and header for exports
- [ ] Table of contents for long conversations
- [ ] Preserve formatting (bold, italic, lists, code)

### PDF Export
- [ ] Professional formatting with MC Press branding
- [ ] Page numbers and headers/footers
- [ ] Syntax-highlighted code blocks
- [ ] Embedded images (if applicable)
- [ ] Hyperlinks to referenced books
- [ ] Export options (page size, margins, font size)
- [ ] Watermark option (e.g., "Generated by MC Press Chatbot")

### Markdown Export
- [ ] Clean, readable Markdown format
- [ ] Code fences with language tags
- [ ] Proper heading hierarchy
- [ ] Links to MC Press books
- [ ] Metadata in front matter (YAML)
- [ ] GitHub-flavored Markdown support
- [ ] Compatible with common Markdown viewers

### User Experience
- [ ] Export button on conversation view
- [ ] Bulk export from conversation list
- [ ] Export options modal (format, style, content)
- [ ] Progress indicator for large exports
- [ ] Download or email export
- [ ] Export history/tracking
- [ ] Preview before export

## Technical Design

### Export Architecture

```
Conversation Data → Export Service → Format Renderer → File Generator → Download
                          ↓               ↓                  ↓
                    Conversation    PDF/Markdown       Generated File
                    Metadata        Templates          (PDF/MD)
```

### Export Service

```python
class ConversationExportService:
    """Export conversations to various formats"""

    def __init__(self, conversation_service, pdf_generator, markdown_generator):
        self.conversations = conversation_service
        self.pdf = pdf_generator
        self.markdown = markdown_generator

    async def export_conversation(
        self,
        conversation_id: str,
        user_id: str,
        format: str = 'pdf',
        options: ExportOptions = None
    ) -> ExportResult:
        """Export conversation to specified format"""

        # Get conversation with messages
        conversation, messages = await self.conversations.get_conversation_with_messages(
            conversation_id, user_id
        )

        # Build export data
        export_data = self._prepare_export_data(
            conversation, messages, options
        )

        # Generate export based on format
        if format == 'pdf':
            file_data = await self.pdf.generate(export_data, options)
            filename = f"{self._sanitize_filename(conversation.title)}.pdf"
            mime_type = 'application/pdf'

        elif format == 'markdown':
            file_data = await self.markdown.generate(export_data, options)
            filename = f"{self._sanitize_filename(conversation.title)}.md"
            mime_type = 'text/markdown'

        else:
            raise ValueError(f"Unsupported format: {format}")

        # Save export record
        export_record = await self._save_export_record(
            user_id, conversation_id, format, filename
        )

        return ExportResult(
            id=export_record.id,
            filename=filename,
            file_data=file_data,
            mime_type=mime_type,
            size=len(file_data)
        )

    async def bulk_export(
        self,
        conversation_ids: List[str],
        user_id: str,
        format: str = 'pdf',
        options: ExportOptions = None
    ) -> ExportResult:
        """Export multiple conversations"""

        # Export each conversation
        exports = []
        for conv_id in conversation_ids:
            export = await self.export_conversation(
                conv_id, user_id, format, options
            )
            exports.append(export)

        # Combine into single file or zip
        if len(exports) == 1:
            return exports[0]
        else:
            # Create ZIP archive
            zip_data = self._create_zip_archive(exports)
            filename = f"conversations_export_{len(exports)}.zip"

            return ExportResult(
                filename=filename,
                file_data=zip_data,
                mime_type='application/zip',
                size=len(zip_data)
            )

    def _prepare_export_data(
        self,
        conversation: Conversation,
        messages: List[Message],
        options: ExportOptions
    ) -> ExportData:
        """Prepare conversation data for export"""

        return ExportData(
            title=options.custom_title or conversation.title,
            subtitle=options.subtitle,
            metadata={
                'created_at': conversation.created_at,
                'updated_at': conversation.updated_at,
                'message_count': len(messages),
                'tags': conversation.tags,
                'summary': conversation.summary
            },
            messages=[
                self._format_message(msg, options)
                for msg in messages
            ],
            table_of_contents=options.include_toc,
            footer=options.footer or "Generated by MC Press Chatbot"
        )

    def _format_message(
        self,
        message: Message,
        options: ExportOptions
    ) -> FormattedMessage:
        """Format message for export"""

        # Extract code blocks
        code_blocks = self._extract_code_blocks(message.content)

        # Extract book references
        book_refs = message.metadata.get('book_references', [])

        return FormattedMessage(
            role=message.role,
            content=message.content,
            code_blocks=code_blocks,
            book_references=book_refs,
            timestamp=message.created_at if options.include_timestamps else None
        )

    def _extract_code_blocks(self, content: str) -> List[CodeBlock]:
        """Extract code blocks with language tags"""

        import re
        pattern = r'```(\w+)?\n(.*?)```'
        matches = re.finditer(pattern, content, re.DOTALL)

        code_blocks = []
        for match in matches:
            language = match.group(1) or 'text'
            code = match.group(2).strip()
            code_blocks.append(CodeBlock(language=language, code=code))

        return code_blocks
```

### PDF Generation

```python
class PDFGenerator:
    """Generate PDF exports using ReportLab or WeasyPrint"""

    def __init__(self):
        # Using WeasyPrint for HTML → PDF conversion
        from weasyprint import HTML, CSS
        self.HTML = HTML
        self.CSS = CSS

    async def generate(
        self,
        export_data: ExportData,
        options: ExportOptions
    ) -> bytes:
        """Generate PDF from export data"""

        # Build HTML from template
        html_content = self._build_html(export_data, options)

        # Apply CSS styling
        css = self._get_pdf_stylesheet(options)

        # Generate PDF
        pdf_bytes = self.HTML(string=html_content).write_pdf(
            stylesheets=[self.CSS(string=css)]
        )

        return pdf_bytes

    def _build_html(
        self,
        export_data: ExportData,
        options: ExportOptions
    ) -> str:
        """Build HTML from export data"""

        # Use Jinja2 template
        from jinja2 import Template

        template = Template(PDF_TEMPLATE)

        html = template.render(
            title=export_data.title,
            subtitle=export_data.subtitle,
            metadata=export_data.metadata,
            messages=export_data.messages,
            table_of_contents=export_data.table_of_contents,
            footer=export_data.footer,
            options=options
        )

        return html

    def _get_pdf_stylesheet(self, options: ExportOptions) -> str:
        """Get CSS stylesheet for PDF"""

        return f"""
        @page {{
            size: {options.page_size or 'letter'};
            margin: {options.margin or '1in'};
            @bottom-center {{
                content: counter(page);
            }}
        }}

        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: {options.font_size or '11pt'};
            line-height: 1.6;
            color: #333;
        }}

        h1 {{
            color: #1a1a1a;
            border-bottom: 3px solid #0066cc;
            padding-bottom: 10px;
        }}

        .message {{
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
        }}

        .message.user {{
            background-color: #f0f4f8;
        }}

        .message.assistant {{
            background-color: #fff;
            border-left: 4px solid #0066cc;
        }}

        .message-role {{
            font-weight: bold;
            margin-bottom: 8px;
            color: #0066cc;
        }}

        pre {{
            background-color: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 10pt;
            line-height: 1.4;
        }}

        code {{
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }}

        .book-reference {{
            background-color: #e7f3ff;
            border-left: 4px solid #0066cc;
            padding: 10px;
            margin: 10px 0;
        }}

        .metadata {{
            color: #666;
            font-size: 9pt;
            margin-bottom: 30px;
        }}

        .footer {{
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ccc;
            text-align: center;
            color: #666;
            font-size: 9pt;
        }}
        """

# PDF Template
PDF_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{{ title }}</title>
</head>
<body>
    <h1>{{ title }}</h1>
    {% if subtitle %}
    <h2>{{ subtitle }}</h2>
    {% endif %}

    <div class="metadata">
        <p><strong>Created:</strong> {{ metadata.created_at.strftime('%Y-%m-%d %H:%M') }}</p>
        <p><strong>Messages:</strong> {{ metadata.message_count }}</p>
        {% if metadata.tags %}
        <p><strong>Tags:</strong> {{ metadata.tags|join(', ') }}</p>
        {% endif %}
    </div>

    {% if table_of_contents %}
    <div class="toc">
        <h2>Table of Contents</h2>
        <!-- Auto-generated TOC -->
    </div>
    {% endif %}

    <div class="messages">
        {% for message in messages %}
        <div class="message {{ message.role }}">
            <div class="message-role">
                {% if message.role == 'user' %}👤 User{% else %}🤖 Assistant{% endif %}
                {% if message.timestamp %}
                <span class="timestamp">{{ message.timestamp.strftime('%H:%M') }}</span>
                {% endif %}
            </div>
            <div class="message-content">
                {{ message.content|safe }}
            </div>

            {% if message.code_blocks %}
            {% for block in message.code_blocks %}
            <pre><code class="language-{{ block.language }}">{{ block.code }}</code></pre>
            {% endfor %}
            {% endif %}

            {% if message.book_references %}
            <div class="book-references">
                <strong>📚 Referenced Books:</strong>
                {% for book in message.book_references %}
                <div class="book-reference">
                    <em>{{ book.title }}</em> by {{ book.author }}
                </div>
                {% endfor %}
            </div>
            {% endif %}
        </div>
        {% endfor %}
    </div>

    <div class="footer">
        {{ footer }}
    </div>
</body>
</html>
"""
```

### Markdown Generation

```python
class MarkdownGenerator:
    """Generate Markdown exports"""

    async def generate(
        self,
        export_data: ExportData,
        options: ExportOptions
    ) -> bytes:
        """Generate Markdown from export data"""

        md_content = self._build_markdown(export_data, options)

        return md_content.encode('utf-8')

    def _build_markdown(
        self,
        export_data: ExportData,
        options: ExportOptions
    ) -> str:
        """Build Markdown content"""

        lines = []

        # Front matter (YAML)
        lines.append("---")
        lines.append(f"title: {export_data.title}")
        if export_data.subtitle:
            lines.append(f"subtitle: {export_data.subtitle}")
        lines.append(f"created: {export_data.metadata['created_at']}")
        lines.append(f"messages: {export_data.metadata['message_count']}")
        if export_data.metadata.get('tags'):
            lines.append(f"tags: [{', '.join(export_data.metadata['tags'])}]")
        lines.append("---")
        lines.append("")

        # Title
        lines.append(f"# {export_data.title}")
        if export_data.subtitle:
            lines.append(f"## {export_data.subtitle}")
        lines.append("")

        # Metadata
        lines.append("**Conversation Details:**")
        lines.append(f"- Created: {export_data.metadata['created_at']}")
        lines.append(f"- Messages: {export_data.metadata['message_count']}")
        if export_data.metadata.get('tags'):
            lines.append(f"- Tags: {', '.join(export_data.metadata['tags'])}")
        if export_data.metadata.get('summary'):
            lines.append(f"\n{export_data.metadata['summary']}")
        lines.append("")
        lines.append("---")
        lines.append("")

        # Messages
        for i, message in enumerate(export_data.messages, 1):
            # Message header
            role_emoji = "👤" if message.role == "user" else "🤖"
            role_name = "User" if message.role == "user" else "Assistant"

            lines.append(f"### {role_emoji} {role_name}")
            if message.timestamp and options.include_timestamps:
                lines.append(f"*{message.timestamp}*")
            lines.append("")

            # Message content
            lines.append(message.content)
            lines.append("")

            # Book references
            if message.book_references:
                lines.append("**📚 Referenced Books:**")
                for book in message.book_references:
                    lines.append(f"- *{book.title}* by {book.author}")
                lines.append("")

            lines.append("---")
            lines.append("")

        # Footer
        lines.append("")
        lines.append(f"*{export_data.footer}*")

        return "\n".join(lines)
```

### Database Schema

```sql
-- Export records
CREATE TABLE IF NOT EXISTS conversation_exports (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    conversation_id TEXT NOT NULL,
    format TEXT NOT NULL,
    filename TEXT NOT NULL,
    file_size INTEGER,
    options JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_exports_user
ON conversation_exports(user_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_exports_conversation
ON conversation_exports(conversation_id);
```

### API Endpoints

```python
POST   /api/conversations/{id}/export          # Export conversation
POST   /api/conversations/bulk-export          # Bulk export
GET    /api/exports/{id}/download              # Download export
GET    /api/exports                            # List user's exports
DELETE /api/exports/{id}                       # Delete export record
```

## Implementation Tasks

### Backend Tasks
- [ ] Create export service
- [ ] Implement PDF generation (WeasyPrint)
- [ ] Implement Markdown generation
- [ ] Build syntax highlighting for code blocks
- [ ] Create export templates
- [ ] Add bulk export functionality
- [ ] Implement ZIP archive creation
- [ ] Create export API endpoints
- [ ] Add export history tracking

### Frontend Tasks
- [ ] Add export button to conversation view
- [ ] Create export options modal
- [ ] Implement bulk export UI
- [ ] Add export preview
- [ ] Build progress indicators
- [ ] Create export history page
- [ ] Add download functionality

### Integration Tasks
- [ ] Integrate with STORY-011 (conversation history)
- [ ] Test PDF generation
- [ ] Test Markdown generation
- [ ] Validate syntax highlighting
- [ ] Test bulk exports

### Dependencies
- [ ] Install WeasyPrint or ReportLab
- [ ] Install Pygments for syntax highlighting
- [ ] Configure file storage for exports

## Testing Requirements

### Unit Tests
- [ ] PDF generation
- [ ] Markdown generation
- [ ] Code block extraction
- [ ] Syntax highlighting
- [ ] ZIP archive creation

### Integration Tests
- [ ] Export conversation to PDF
- [ ] Export conversation to Markdown
- [ ] Bulk export multiple conversations
- [ ] Download exported file

### E2E Tests
- [ ] Export single conversation
- [ ] Export with custom options
- [ ] Bulk export conversations
- [ ] View export history
- [ ] Download and verify export

## Success Metrics

- **Export Usage**: 15% of users export conversations
- **Format Distribution**: 60% PDF, 40% Markdown
- **Bulk Export Usage**: 5% of exports are bulk
- **Average Exports**: 2 per month per active user
- **Export Satisfaction**: 4+ stars

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All tests passing
- [ ] Code reviewed and approved
- [ ] PDF quality validated
- [ ] Markdown compatibility tested
- [ ] Documentation updated
- [ ] Deployed to staging
- [ ] UAT completed
- [ ] Production deployment successful

## Dependencies

- STORY-011 (Conversation History) - Must be completed first
- WeasyPrint or ReportLab library
- Pygments for syntax highlighting

## Risks

- **Risk**: PDF generation performance issues
  - **Mitigation**: Async processing, caching, optimize templates

- **Risk**: Large exports timeout
  - **Mitigation**: Background processing, email delivery option

## Future Enhancements

- Export to DOCX
- Export to HTML
- Custom branding/themes
- Email export option
- Scheduled exports
- Export to cloud storage (Google Drive, Dropbox)

---

## Notes

Keep exports clean and professional. These may be used for customer documentation, training materials, and compliance records.
